#!/usr/bin/env bash

# Public: This exists so arguments passed to wickRun are not passed to
# formulas.
#
# $1 - Formula command to execute, including arguments.  Already escaped.
#
# *Escaping note:* Formulas that are passed in are already quoted and must not
# be quoted again if you want this to run properly.  See `wickFormula` for
# quoting.
#
# Sets `WICK_FORMULA_DIR` to the directory of the currently executing formula.
# Sets `WICK_FORMULA_NAME` to just the name of the currently executing
# formula.
#
# Returns the status code from the formula.
wickRunFormula() {
    local formula result WICK_FORMULA_DIR WICK_FORMULA_NAME

    formula=$1
    shift

    # Only use echo - do not log this to the file because the arguments
    # may contain secret keys.  Logging just the formula's name would be
    # acceptable.
    echo "Executing formula: $formula"

    # See escaping note above
    eval "WICK_FORMULA_DIR=($formula)"
    export WICK_FORMULA_DIR=${WICK_FORMULA_DIR[0]%/*}
    export WICK_FORMULA_NAME=${WICK_FORMULA_DIR##*/}

    # See escaping note in function header
    # Can't use `. $formula` by itself because parameters get
    # double-escaped.
    #
    #   arg1() { printf "%q" "$1"; }
    #   arg1 a\{b # prints "a\{b"
    #   test="arg1 a\{b"
    #   $test # prints "a\\\{b"
    #
    # We need to run this via wickStrictRun capture the exit code
    # instead of in the if statement for the latest version of bash.
    # In previous versions (4.1.2) this worked but in the later versions
    # (4.3.46) it appears not to.  Apparently according to the POSIX
    # when running anything within certain contexts (in our case inside
    # an if statement) then it behaves as if -e is not set.  This means
    # that a subshell (or function) will return the exit code of the
    # last command ran.  As an example
    #
    #   f() {
    #      fTwo
    #      echo "hello"
    #   }
    #
    #   fTwo() {
    #       return 1
    #   }
    #
    #   set -e
    #
    #   if f; then
    #       echo "Not expected"
    #   fi
    #
    # This would output "Not expected".  The same is also true when using
    # subshells.  Even setting -e inside of the subshell will not make it
    # work.  A good description is here http://unix.stackexchange.com/questions/65532/why-does-set-e-not-work-inside
    wickStrictRun result eval "(wickStrictMode ; . $formula)"

    if [[ "$result" -ne 0 ]]; then
        echo "FAILURE DETECTED"
        # Only use echo - do not log this to the file because the arguments
        # may contain secret keys.  Logging just the formula's name would be
        # acceptable.
        echo "Formula failure: $formula"
        return 1
    fi

    # Only use echo - do not log this to the file because the arguments
    # may contain secret keys.  Logging just the formula's name would be
    # acceptable.
    echo "Formula success: $formula"
}
