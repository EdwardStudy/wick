#!/usr/bin/env bash
# Enables [strict mode] for Bash, based off [unofficial bash strict mode].
# Errors will kill the program.  Accessing undefined variables will cause
# errors (and exit the program).  Commands in pipelines that return a non-zero
# status code will also cause errors and kill the program.  An ERR trap is also
# enabled that will produce a stack trace when errors happen.
#
# This is intended to be used at the beginning of your shell scripts in order
# to ensure correctness in your programming.
#
# Please check out the detailed explanation of [strict mode] for further
# information.
#
# Examples
#
#   #!/usr/bin/env bash
#   . /usr/local/lib/wick-infect
#   wickStrictMode
#
# [unofficial bash strict mode]: http://redsymbol.net/articles/unofficial-bash-strict-mode/
#
# [strict mode]: ../docs/bash-strict-mode.md
#
# Returns nothing.
wickStrictMode() {
    set -eEu -o pipefail
    shopt -s extdebug
    IFS=$'\n\t'
    trap 'wickStrictModeFail $?' ERR
}


# Internal: The ERR trap calls this function to report on the error location
# right before dying.  See `wickStrictMode` for further details.
#
# $1 - Status from failed command.
#
# Returns nothing.
wickStrictModeFail() (
    set +x
    local argsList argsLeft i nextArg

    echo "Error detected - status code $1"
    echo "Command:  $BASH_COMMAND"
    echo "Location:  ${BASH_SOURCE[1]:-unknown}, line ${BASH_LINENO[0]:-unknown}"

    if [[ ${#PIPESTATUS[@]} -gt 1 ]]; then
        echo "Pipe status: " "${PIPESTATUS[@]}"
    fi

    i=$#
    nextArg=$#

    if [[ $i -lt ${#BASH_LINENO[@]} ]]; then
        echo "Stack Trace:"
    else
        echo "Stack trace is unavailable"
    fi

    while [[ $i -lt ${#BASH_LINENO[@]} ]]; do
        argsList=()

        if [[ ${#BASH_ARGC[@]} -gt $i ]] && [[ ${#BASH_ARGV[@]} -ge $(( nextArg + ${BASH_ARGC[i]} )) ]]; then
            for (( argsLeft = ${BASH_ARGC[i]}; argsLeft; --argsLeft )); do
                # Note: this reverses the order on purpose
                argsList[$argsLeft]=${BASH_ARGV[nextArg]}
                (( nextArg ++ ))
            done

            if [[ ${#argsList[@]} -gt 0 ]]; then
                printf -v argsList " %q" "${argsList[@]}"
            else
                argsList=""
            fi

            if [[ ${#argsList} -gt 255 ]]; then
                argsList=${argsList:0:250}...
            fi
        else
            argsList=""
        fi

        echo "    [$i] ${FUNCNAME[i]:+${FUNCNAME[i]}(): }${BASH_SOURCE[i]}, line ${BASH_LINENO[i - 1]} -> ${FUNCNAME[i]:-${BASH_SOURCE[i]##*/}}$argsList"
        (( i ++ ))
    done
)
