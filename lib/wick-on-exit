#!/usr/bin/env bash
# Public: Run a command when the currently executing script or subshell ends.
#
# $1   - The command to execute.
# $2-@ - Optional arguments to pass to the command.
#
# Examples
#
#    # Download a file
#    wickGetUrl http://example.com/installer.tar.gz /tmp/installer.tar.gz
#
#    # When done, clean it up
#    wickOnExit rm -f /tmp/installer.tar.gz
#
# Returns nothing.
wickOnExit() {
    local cmd length name

    name="WICK_ON_EXIT_$BASHPID"

    if ! declare -p $name > /dev/null 2>&1; then
        eval "$name=()"
    fi

    # Note:  I am not a fan of eval.  If you have a better way to do this that
    # uses fewer evaluated statements that also works from Bash 3 through the
    # latest release and with "set -eu", then I'd LOVE to know.
    eval "length=\${#$name[@]}"
    wickArgumentString cmd "$@"
    wickDebug "Adding wickOnExit item [$BASHPID $length]: ${cmd}"
    eval "$name[$length]=\$cmd"

    # Always set or reset the trap
    trap wickOnExitTrap EXIT
}


# Internal: Function that runs the wickOnExit commands.  This is set as the
# EXIT trap in Bash to ensure that it always executes at the end of a script or
# subshell.
wickOnExitTrap() {
    local cmd itemArray length name

    name="WICK_ON_EXIT_$BASHPID"

    if ! declare -p "$name" > /dev/null 2>&1; then
        wickDebug "No array of wickOnExit traps [$BASHPID]"
        return
    fi

    itemArray="$name[@]"

    # See note above about using `eval`.
    eval "length=\${#$itemArray}"

    if [[ "$length" == 0 ]]; then
        wickDebug "Empty list of wickOnExit traps [$BASHPID]"
        return
    fi

    wickDebug "Running wickOnExit trap [$BASHPID]"

    for cmd in "${!itemArray}"; do
        wickDebug "Running wickOnExit command: $cmd"
        eval $cmd
    done

    wickDebug "Done running wickOnExit traps"
}
